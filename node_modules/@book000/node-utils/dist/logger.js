"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const winston_1 = __importStar(require("winston"));
const winston_daily_rotate_file_1 = __importDefault(require("winston-daily-rotate-file"));
const cycle_1 = __importDefault(require("cycle"));
/**
 * ロガーラッパークラス
 */
class Logger {
    constructor(logger) {
        this.logger = logger;
    }
    /**
     * デバッグログを出力する
     *
     * @param message メッセージ
     * @param metadata メタデータ
     */
    debug(message, metadata) {
        this.logger.debug(message, metadata || {});
    }
    /**
     * 情報ログを出力する
     *
     * @param message メッセージ
     * @param metadata メタデータ
     */
    info(message, metadata) {
        this.logger.info(message, metadata || {});
    }
    /**
     * 警告ログを出力する
     *
     * @param message メッセージ
     * @param error エラー
     */
    warn(message, error) {
        this.logger.warn(message, error);
    }
    /**
     * エラーログを出力する
     *
     * @param message メッセージ
     * @param error エラー
     */
    error(message, error) {
        this.logger.error(message, error);
    }
    /**
     * ロガーを初期化・設定する
     *
     * 環境変数で以下の設定が可能
     * - LOG_LEVEL: ログレベル (デフォルト info)
     * - LOG_FILE_LEVEL: ファイル出力のログレベル (デフォルト info)
     * - LOG_DIR: ログ出力先 (デフォルト logs)
     * - LOG_FILE_MAX_AGE: ログファイルの最大保存期間 (デフォルト 30d)
     * - LOG_FILE_FORMAT: ログファイルのフォーマット (デフォルト text)
     *
     * @param category カテゴリ
     * @returns ロガー
     */
    static configure(category) {
        const logLevel = process.env.LOG_LEVEL || 'info';
        const logFileLevel = process.env.LOG_FILE_LEVEL || 'info';
        const logDirectory = process.env.LOG_DIR || 'logs';
        const logFileMaxAge = process.env.LOG_FILE_MAX_AGE || '30d';
        const selectLogFileFormat = process.env.LOG_FILE_FORMAT || 'text';
        const textFormat = winston_1.format.printf((info) => {
            const { timestamp, level, message, ...rest } = info;
            // eslint-disable-next-line unicorn/no-array-reduce
            const filteredRest = Object.keys(rest).reduce((accumulator, key) => {
                if (key === 'stack') {
                    return accumulator;
                }
                return {
                    ...accumulator,
                    [key]: rest[key],
                };
            }, {});
            const standardLine = [
                '[',
                timestamp,
                '] [',
                category ?? '',
                category ? '/' : '',
                level.toLocaleUpperCase(),
                ']: ',
                message,
                Object.keys(filteredRest).length > 0
                    ? ` (${JSON.stringify(filteredRest)})`
                    : '',
            ].join('');
            const errorLine = info.stack
                ? info.stack.split('\n').slice(1).join('\n')
                : undefined;
            return [standardLine, errorLine].filter((l) => l !== undefined).join('\n');
        });
        const logFileFormat = selectLogFileFormat === 'ndjson' ? winston_1.format.json() : textFormat;
        const decycleFormat = (0, winston_1.format)((info) => cycle_1.default.decycle(info));
        const fileFormat = winston_1.format.combine(...[
            winston_1.format.errors({ stack: true }),
            selectLogFileFormat === 'ndjson'
                ? winston_1.format.colorize({
                    message: true,
                })
                : winston_1.format.uncolorize(),
            decycleFormat(),
            winston_1.format.timestamp({
                format: 'YYYY-MM-DD hh:mm:ss.SSS',
            }),
            logFileFormat,
        ].filter((f) => f !== undefined));
        const consoleFormat = winston_1.format.combine(...[
            winston_1.format.colorize({
                message: true,
            }),
            decycleFormat(),
            winston_1.format.timestamp({
                format: 'YYYY-MM-DD hh:mm:ss.SSS',
            }),
            textFormat,
        ].filter((f) => f !== undefined));
        const extension = selectLogFileFormat === 'ndjson' ? 'ndjson' : 'log';
        const transportRotateFile = new winston_daily_rotate_file_1.default({
            level: logFileLevel,
            dirname: logDirectory,
            filename: `%DATE%.` + extension,
            datePattern: 'YYYY-MM-DD',
            maxFiles: logFileMaxAge,
            format: fileFormat,
            auditFile: `${logDirectory}/audit.json`,
        });
        const logger = winston_1.default.createLogger({
            transports: [
                new winston_1.default.transports.Console({
                    level: logLevel,
                    format: consoleFormat,
                }),
                transportRotateFile,
            ],
        });
        return new Logger(logger);
    }
}
exports.Logger = Logger;
process.on('unhandledRejection', (reason) => {
    const logger = Logger.configure('main');
    logger.error('unhandledRejection', reason);
});
process.on('uncaughtException', (error) => {
    const logger = Logger.configure('main');
    logger.error('uncaughtException', error);
});
//# sourceMappingURL=logger.js.map