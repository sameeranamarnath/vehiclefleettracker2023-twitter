"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomTypesGenerator = void 0;
const node_utils_1 = require("@book000/node-utils");
const dist_1 = require("genson-js/dist");
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
const node_path_1 = require("node:path");
const node_fs_1 = __importDefault(require("node:fs"));
const utils_1 = require("./utils");
/**
 * カスタム型定義を生成するクラス
 */
class CustomTypesGenerator {
    /**
     * @param results エンドポイントごとのレスポンス情報
     * @param schemaDirectory スキーマ保存ディレクトリ
     * @param typesDirectory 型定義保存ディレクトリ
     */
    constructor(results, schemaDirectory, typesDirectory) {
        this.results = results;
        this.schemaDirectory = schemaDirectory;
        this.typesDirectory = typesDirectory;
    }
    /**
     * 検索タイムラインツイートモデル（CustomSearchTimelineEntry）のカスタム型定義を生成する
     */
    async runGraphQLSearchTimeline() {
        const results = this.results.filter((result) => result.type === 'graphql' &&
            result.name === 'SearchTimeline' &&
            result.method === 'GET' &&
            result.statusCode === '200');
        if (results.length === 0) {
            return;
        }
        const paths = results.flatMap((result) => result.paths);
        let schema;
        for (const path of paths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.search_by_raw_query.search_timeline.timeline.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomSearchTimelineEntry', '検索タイムラインツイートモデル');
    }
    /**
     * ユーザーツイートモデル（CustomUserTweetEntry）のカスタム型定義を生成する
     */
    async runGraphQLUserTweets() {
        const results = this.results.filter((result) => result.type === 'graphql' &&
            result.name === 'UserTweets' &&
            result.method === 'GET' &&
            result.statusCode === '200');
        if (results.length === 0) {
            return;
        }
        const paths = results.flatMap((result) => result.paths);
        let schema;
        for (const path of paths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.user.result.timeline_v2.timeline.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomUserTweetEntry', 'ユーザーツイートモデル');
    }
    /**
     * ユーザーいいねツイートモデル（CustomUserLikeTweetEntry）のカスタム型定義を生成する
     */
    async runGraphQLUserLikeTweets() {
        const results = this.results.filter((result) => result.type === 'graphql' &&
            result.name === 'Likes' &&
            result.method === 'GET' &&
            result.statusCode === '200');
        if (results.length === 0) {
            return;
        }
        const paths = results.flatMap((result) => result.paths);
        let schema;
        for (const path of paths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.user.result.timeline_v2.timeline.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomUserLikeTweetEntry', 'ユーザーいいねツイートエントリモデル');
    }
    /**
     * GET・POSTメソッド共通のホームタイムラインモデルのカスタム型定義を生成する
     */
    async runGraphQLTimeline() {
        const homeTimelineResults = this.results.filter((result) => result.type === 'graphql' &&
            (result.name === 'HomeTimeline' ||
                result.name === 'HomeLatestTimeline') &&
            (result.method === 'GET' || result.method === 'POST') &&
            result.statusCode === '200');
        if (homeTimelineResults.length === 0) {
            return;
        }
        const hometimelinePaths = homeTimelineResults.flatMap((result) => result.paths);
        let schema;
        for (const path of hometimelinePaths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const fileSchema = (0, dist_1.createSchema)(response);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomGraphQLTimelineSuccessResponse', 'ホームタイムラインモデル');
    }
    /**
     * タイムラインツイートモデル（CustomTimelineTweetEntry）のカスタム型定義を生成する
     */
    async runGraphQLTimelineTweetEntry() {
        const homeTimelineResults = this.results.filter((result) => result.type === 'graphql' &&
            (result.name === 'HomeTimeline' ||
                result.name === 'HomeLatestTimeline') &&
            (result.method === 'GET' || result.method === 'POST') &&
            result.statusCode === '200');
        if (homeTimelineResults.length === 0) {
            return;
        }
        const hometimelinePaths = homeTimelineResults.flatMap((result) => result.paths);
        let schema;
        for (const path of hometimelinePaths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.home.home_timeline_urt.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomTimelineTweetEntry', 'ホームタイムラインツイートエントリモデル');
    }
    // --- twitter-d 変換用オブジェクト
    /**
     * レスポンスツイートオブジェクト（CustomTweetObject）のカスタム型定義を生成する
     */
    async runTweetObject() {
        // 各レスポンスからツイートオブジェクトを抽出
        const schemas = [
            // HomeTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'HomeTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.home.home_timeline_urt.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // HomeLatestTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'HomeLatestTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.home.home_timeline_urt.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // SearchTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'SearchTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.search_by_raw_query.search_timeline.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserTweets
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserTweets' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // Likes
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'Likes' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
        ].flat();
        await this.generateTypeFromSchema((0, dist_1.mergeSchemas)(schemas), 'CustomTweetObject', 'レスポンスツイートオブジェクト');
    }
    /**
     * レスポンスツイートレガシーオブジェクト（CustomTweetLegacyObject）のカスタム型定義を生成する
     */
    async runTweetLegacyObject() {
        // 各レスポンスからレガシーツイートオブジェクトを抽出
        const schemas = [
            // SearchTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'SearchTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.search_by_raw_query.search_timeline.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserTweets: tweet_results.result.legacy
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserTweets' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .filter((entry) => entry.content.itemContent.tweet_results
                .result.legacy !== undefined)
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserTweets: tweet_results.result.tweet?.legacy
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserTweets' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .filter((entry) => entry.content.itemContent.tweet_results
                .result.tweet?.legacy !== undefined)
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result.tweet?.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
        ].flat();
        await this.generateTypeFromSchema((0, dist_1.mergeSchemas)(schemas), 'CustomTweetLegacyObject', 'レスポンスツイートレガシーオブジェクト');
    }
    /**
     * レスポンスユーザーレガシーオブジェクト（CustomUserLegacyObject）のカスタム型定義を生成する
     */
    async runUserLegacyObject() {
        // 各レスポンスからレガシーユーザーオブジェクトを抽出
        const schemas = [
            // UserByRestId
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserByRestId' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserByScreenName
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserByScreenName' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
        ].flat();
        await this.generateTypeFromSchema((0, dist_1.mergeSchemas)(schemas), 'CustomUserLegacyObject', 'レスポンスユーザーレガシーオブジェクト');
    }
    /**
     * カスタム型定義を、スキーマを元に生成する
     *
     * @param schema スキーマ
     * @param name 型名
     * @param tsDocument 型定義の tsdoc（1 行で記述）
     */
    async generateTypeFromSchema(schema, name, tsDocument) {
        const logger = node_utils_1.Logger.configure('CustomTypeGenerator.generateTypeFromSchema');
        if (!schema) {
            throw new Error('No schema found');
        }
        const kebabName = name.replaceAll(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        const schemaPath = (0, node_path_1.join)(this.schemaDirectory, 'custom', `${kebabName}.json`);
        const typesPath = (0, node_path_1.join)(this.typesDirectory, 'custom', `${kebabName}.ts`);
        node_fs_1.default.mkdirSync((0, node_path_1.dirname)(schemaPath), { recursive: true });
        node_fs_1.default.writeFileSync(schemaPath, JSON.stringify(schema, null, 2));
        node_fs_1.default.mkdirSync((0, node_path_1.dirname)(typesPath), { recursive: true });
        const types = await (0, json_schema_to_typescript_1.compile)(schema, name, utils_1.Utils.getCompileOptions(tsDocument));
        node_fs_1.default.writeFileSync(typesPath, types);
        logger.info(`📝 ${name}`);
    }
    /**
     * カスタム型定義を生成する
     */
    async generate(parallel) {
        const generators = [
            this.runGraphQLSearchTimeline.bind(this),
            this.runGraphQLUserTweets.bind(this),
            this.runGraphQLUserLikeTweets.bind(this),
            this.runGraphQLTimeline.bind(this),
            this.runGraphQLTimelineTweetEntry.bind(this),
            this.runTweetObject.bind(this),
            // twitter-d 変換用オブジェクト
            this.runTweetLegacyObject.bind(this),
            this.runUserLegacyObject.bind(this),
        ];
        if (parallel) {
            await Promise.all(generators.map((generator) => generator()));
        }
        else {
            for (const generator of generators) {
                await generator();
            }
        }
    }
}
exports.CustomTypesGenerator = CustomTypesGenerator;
//# sourceMappingURL=custom-types-generator.js.map