"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomTypesGenerator = void 0;
const node_utils_1 = require("@book000/node-utils");
const dist_1 = require("genson-js/dist");
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
const node_path_1 = require("node:path");
const node_fs_1 = __importDefault(require("node:fs"));
const utils_1 = require("./utils");
/**
 * ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
class CustomTypesGenerator {
    /**
     * @param results ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã”ã¨ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹æƒ…å ±
     * @param schemaDirectory ã‚¹ã‚­ãƒ¼ãƒžä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
     * @param typesDirectory åž‹å®šç¾©ä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
     */
    constructor(results, schemaDirectory, typesDirectory) {
        this.results = results;
        this.schemaDirectory = schemaDirectory;
        this.typesDirectory = typesDirectory;
    }
    /**
     * æ¤œç´¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ï¼ˆCustomSearchTimelineEntryï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runGraphQLSearchTimeline() {
        const results = this.results.filter((result) => result.type === 'graphql' &&
            result.name === 'SearchTimeline' &&
            result.method === 'GET' &&
            result.statusCode === '200');
        if (results.length === 0) {
            return;
        }
        const paths = results.flatMap((result) => result.paths);
        let schema;
        for (const path of paths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.search_by_raw_query.search_timeline.timeline.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomSearchTimelineEntry', 'æ¤œç´¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«');
    }
    /**
     * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ï¼ˆCustomUserTweetEntryï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runGraphQLUserTweets() {
        const results = this.results.filter((result) => result.type === 'graphql' &&
            result.name === 'UserTweets' &&
            result.method === 'GET' &&
            result.statusCode === '200');
        if (results.length === 0) {
            return;
        }
        const paths = results.flatMap((result) => result.paths);
        let schema;
        for (const path of paths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.user.result.timeline_v2.timeline.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomUserTweetEntry', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«');
    }
    /**
     * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã„ã„ã­ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ï¼ˆCustomUserLikeTweetEntryï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runGraphQLUserLikeTweets() {
        const results = this.results.filter((result) => result.type === 'graphql' &&
            result.name === 'Likes' &&
            result.method === 'GET' &&
            result.statusCode === '200');
        if (results.length === 0) {
            return;
        }
        const paths = results.flatMap((result) => result.paths);
        let schema;
        for (const path of paths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.user.result.timeline_v2.timeline.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomUserLikeTweetEntry', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã„ã„ã­ãƒ„ã‚¤ãƒ¼ãƒˆã‚¨ãƒ³ãƒˆãƒªãƒ¢ãƒ‡ãƒ«');
    }
    /**
     * GETãƒ»POSTãƒ¡ã‚½ãƒƒãƒ‰å…±é€šã®ãƒ›ãƒ¼ãƒ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runGraphQLTimeline() {
        const homeTimelineResults = this.results.filter((result) => result.type === 'graphql' &&
            (result.name === 'HomeTimeline' ||
                result.name === 'HomeLatestTimeline') &&
            (result.method === 'GET' || result.method === 'POST') &&
            result.statusCode === '200');
        if (homeTimelineResults.length === 0) {
            return;
        }
        const hometimelinePaths = homeTimelineResults.flatMap((result) => result.paths);
        let schema;
        for (const path of hometimelinePaths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const fileSchema = (0, dist_1.createSchema)(response);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomGraphQLTimelineSuccessResponse', 'ãƒ›ãƒ¼ãƒ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«');
    }
    /**
     * ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ï¼ˆCustomTimelineTweetEntryï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runGraphQLTimelineTweetEntry() {
        const homeTimelineResults = this.results.filter((result) => result.type === 'graphql' &&
            (result.name === 'HomeTimeline' ||
                result.name === 'HomeLatestTimeline') &&
            (result.method === 'GET' || result.method === 'POST') &&
            result.statusCode === '200');
        if (homeTimelineResults.length === 0) {
            return;
        }
        const hometimelinePaths = homeTimelineResults.flatMap((result) => result.paths);
        let schema;
        for (const path of hometimelinePaths) {
            const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            const entries = response.data.home.home_timeline_urt.instructions
                .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                entry.entryId.startsWith('promoted-tweet') ||
                entry.entryId.startsWith('promotedTweet')));
            const fileSchema = (0, dist_1.createCompoundSchema)(entries);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            return;
        }
        await this.generateTypeFromSchema(schema, 'CustomTimelineTweetEntry', 'ãƒ›ãƒ¼ãƒ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ„ã‚¤ãƒ¼ãƒˆã‚¨ãƒ³ãƒˆãƒªãƒ¢ãƒ‡ãƒ«');
    }
    // --- twitter-d å¤‰æ›ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    /**
     * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ„ã‚¤ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆCustomTweetObjectï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runTweetObject() {
        // å„ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ãƒ„ã‚¤ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡º
        const schemas = [
            // HomeTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'HomeTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.home.home_timeline_urt.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // HomeLatestTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'HomeLatestTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.home.home_timeline_urt.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // SearchTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'SearchTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.search_by_raw_query.search_timeline.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserTweets
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserTweets' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // Likes
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'Likes' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result;
            })
                .filter((entry) => !!entry)
                .map((entry) => {
                return {
                    ...entry,
                    __entryId: 'string',
                };
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
        ].flat();
        await this.generateTypeFromSchema((0, dist_1.mergeSchemas)(schemas), 'CustomTweetObject', 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ„ã‚¤ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ');
    }
    /**
     * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¬ã‚¬ã‚·ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆCustomTweetLegacyObjectï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runTweetLegacyObject() {
        // å„ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ„ã‚¤ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡º
        const schemas = [
            // SearchTimeline
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'SearchTimeline' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.search_by_raw_query.search_timeline.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserTweets: tweet_results.result.legacy
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserTweets' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .filter((entry) => entry.content.itemContent.tweet_results
                .result.legacy !== undefined)
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserTweets: tweet_results.result.tweet?.legacy
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserTweets' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.timeline_v2.timeline.instructions
                    .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
                    .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
                    entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')));
            })
                .filter((entry) => entry.content.itemContent.tweet_results
                .result.tweet?.legacy !== undefined)
                .map((entry) => {
                return entry.content.itemContent
                    .tweet_results.result.tweet?.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
        ].flat();
        await this.generateTypeFromSchema((0, dist_1.mergeSchemas)(schemas), 'CustomTweetLegacyObject', 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ„ã‚¤ãƒ¼ãƒˆãƒ¬ã‚¬ã‚·ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ');
    }
    /**
     * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ã‚¬ã‚·ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆCustomUserLegacyObjectï¼‰ã®ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async runUserLegacyObject() {
        // å„ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡º
        const schemas = [
            // UserByRestId
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserByRestId' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
            // UserByScreenName
            this.results
                .filter((result) => result.type === 'graphql' &&
                result.name === 'UserByScreenName' &&
                result.method === 'GET' &&
                result.statusCode === '200')
                .flatMap((result) => result.paths)
                .flatMap((path) => {
                const response = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
                return response.data.user.result.legacy;
            })
                .map((entry) => (0, dist_1.createSchema)(entry)),
        ].flat();
        await this.generateTypeFromSchema((0, dist_1.mergeSchemas)(schemas), 'CustomUserLegacyObject', 'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ã‚¬ã‚·ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ');
    }
    /**
     * ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ã€ã‚¹ã‚­ãƒ¼ãƒžã‚’å…ƒã«ç”Ÿæˆã™ã‚‹
     *
     * @param schema ã‚¹ã‚­ãƒ¼ãƒž
     * @param name åž‹å
     * @param tsDocument åž‹å®šç¾©ã® tsdocï¼ˆ1 è¡Œã§è¨˜è¿°ï¼‰
     */
    async generateTypeFromSchema(schema, name, tsDocument) {
        const logger = node_utils_1.Logger.configure('CustomTypeGenerator.generateTypeFromSchema');
        if (!schema) {
            throw new Error('No schema found');
        }
        const kebabName = name.replaceAll(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        const schemaPath = (0, node_path_1.join)(this.schemaDirectory, 'custom', `${kebabName}.json`);
        const typesPath = (0, node_path_1.join)(this.typesDirectory, 'custom', `${kebabName}.ts`);
        node_fs_1.default.mkdirSync((0, node_path_1.dirname)(schemaPath), { recursive: true });
        node_fs_1.default.writeFileSync(schemaPath, JSON.stringify(schema, null, 2));
        node_fs_1.default.mkdirSync((0, node_path_1.dirname)(typesPath), { recursive: true });
        const types = await (0, json_schema_to_typescript_1.compile)(schema, name, utils_1.Utils.getCompileOptions(tsDocument));
        node_fs_1.default.writeFileSync(typesPath, types);
        logger.info(`ðŸ“ ${name}`);
    }
    /**
     * ã‚«ã‚¹ã‚¿ãƒ åž‹å®šç¾©ã‚’ç”Ÿæˆã™ã‚‹
     */
    async generate(parallel) {
        const generators = [
            this.runGraphQLSearchTimeline.bind(this),
            this.runGraphQLUserTweets.bind(this),
            this.runGraphQLUserLikeTweets.bind(this),
            this.runGraphQLTimeline.bind(this),
            this.runGraphQLTimelineTweetEntry.bind(this),
            this.runTweetObject.bind(this),
            // twitter-d å¤‰æ›ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            this.runTweetLegacyObject.bind(this),
            this.runUserLegacyObject.bind(this),
        ];
        if (parallel) {
            await Promise.all(generators.map((generator) => generator()));
        }
        else {
            for (const generator of generators) {
                await generator();
            }
        }
    }
}
exports.CustomTypesGenerator = CustomTypesGenerator;
//# sourceMappingURL=custom-types-generator.js.map