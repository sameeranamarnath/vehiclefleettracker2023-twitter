"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitterTypesGenerator = void 0;
const node_utils_1 = require("@book000/node-utils");
const dist_1 = require("genson-js/dist");
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
const node_path_1 = require("node:path");
const node_fs_1 = __importDefault(require("node:fs"));
const utils_1 = require("./utils");
/**
 * 型定義生成クラス
 */
class TwitterTypesGenerator {
    /**
     * @param options 型定義生成クラスのオプション
     */
    constructor(results) {
        this.results = results;
    }
    /**
     * エンドポイントの型定義を生成する
     *
     * @param options 単一の型定義生成オプション
     * @param result エンドポイントごとのレスポンス情報
     */
    async generateType(options, result) {
        const logger = node_utils_1.Logger.configure('TwitterGenerateTypes.generateType');
        if (result.paths.length === 0) {
            return;
        }
        logger.info(`🔍 Generating: ${options.name}`);
        let schema;
        for (const path of result.paths) {
            const data = utils_1.Utils.parseJsonc(node_fs_1.default.readFileSync(path, 'utf8'));
            if (!data)
                continue;
            if (options.ignoreError && 'errors' in data && data.errors.length > 0) {
                logger.warn(`⚠️ ${path}: ${data.errors[0].message}`);
                continue;
            }
            const fileSchema = (0, dist_1.createSchema)(data);
            schema = schema ? (0, dist_1.mergeSchemas)([schema, fileSchema]) : fileSchema;
        }
        if (!schema) {
            throw new Error('No schema found');
        }
        node_fs_1.default.mkdirSync((0, node_path_1.dirname)(options.path.schema), { recursive: true });
        node_fs_1.default.writeFileSync(options.path.schema, JSON.stringify(schema, null, 2));
        node_fs_1.default.mkdirSync((0, node_path_1.dirname)(options.path.types), { recursive: true });
        const types = await (0, json_schema_to_typescript_1.compile)(schema, options.name, utils_1.Utils.getCompileOptions(options.tsDocument));
        node_fs_1.default.writeFileSync(options.path.types, types);
        logger.info(`📝 Successful: ${options.name} (from ${result.paths.length} files)`);
    }
    /**
     * 保存されたデバッグレスポンスを元に、全てのエンドポイントの型定義を生成する。
     *
     * @param options 型定義生成オプション
     */
    async generateTypes(options) {
        const generators = [];
        for (const result of this.results) {
            const name = utils_1.Utils.getName(result.type, result.name, result.method, result.statusCode);
            const filename = utils_1.Utils.getFilename(result.type, result.name, result.method, result.statusCode);
            const schemaPath = `${options.directory.schema}/${filename}.json`;
            const typesPath = `${options.directory.types}/${filename}.ts`;
            const type = result.type === 'graphql' ? 'GraphQL' : null;
            if (!type)
                continue;
            const generator = this.generateType({
                path: {
                    schema: schemaPath,
                    types: typesPath,
                },
                name,
                tsDocument: `${type} ${result.method} ${result.name} ${result.statusCode.startsWith('2') ? '成功' : '失敗'}レスポンスモデル`,
                ignoreError: result.statusCode.startsWith('2'),
            }, result);
            if (options.parallel) {
                generators.push(generator);
            }
            else {
                await generator;
            }
        }
        await Promise.all(generators);
    }
}
exports.TwitterTypesGenerator = TwitterTypesGenerator;
//# sourceMappingURL=types-generator.js.map