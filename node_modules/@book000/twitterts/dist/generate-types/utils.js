"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const node_path_1 = require("node:path");
const node_fs_1 = __importDefault(require("node:fs"));
const jsonc_parser_1 = require("jsonc-parser");
const node_utils_1 = require("@book000/node-utils");
/**
 * ユーティリティ
 */
exports.Utils = {
    /**
     * JSONC をパースする
     *
     * @param data パースする JSONC 文字列
     * @returns パース結果
     */
    parseJsonc(data) {
        return (0, jsonc_parser_1.parse)(data);
    },
    /**
     * ディレクトリ内にあるディレクトリ群を取得する
     *
     * @param parentDirectory ディレクトリを取得する親ディレクトリパス
     * @param baseDirectories ディレクトリを取得する子ディレクトリパス群
     * @returns ディレクトリ群
     */
    getDirectories(parentDirectory, baseDirectories = []) {
        const baseDirectory = (0, node_path_1.join)(parentDirectory, ...baseDirectories);
        return node_fs_1.default
            .readdirSync(baseDirectory)
            .filter((directory) => !['.', '..'].includes(directory) &&
            node_fs_1.default.statSync(`${baseDirectory}/${directory}`).isDirectory());
    },
    /**
     * ディレクトリ内にある JSON ファイル群を取得する
     *
     * @param parentDirectory ファイルを取得する親ディレクトリパス
     * @param baseDirectories ファイルを取得するディレクトリパス
     * @returns JSON ファイル群
     */
    getJSONFiles(parentDirectory, baseDirectories = []) {
        const baseDirectory = (0, node_path_1.join)(parentDirectory, ...baseDirectories);
        return node_fs_1.default
            .readdirSync(baseDirectory)
            .filter((file) => !['.', '..'].includes(file) &&
            node_fs_1.default.statSync((0, node_path_1.join)(baseDirectory, file)).isFile() &&
            file.endsWith('.json'))
            .map((file) => (0, node_path_1.join)(baseDirectory, file));
    },
    /**
     * レスポンスデバッグ出力 JSON ファイルを元に、エンドポイントごとの情報をまとめて取得する
     *
     * @returns エンドポイントごとの情報
     */
    getEndPointResponses(debugOutputDirectory) {
        const logger = node_utils_1.Logger.configure('Utils:getEndPointResponses');
        const results = [];
        for (const type of this.getDirectories(debugOutputDirectory)) {
            for (const name of this.getDirectories(debugOutputDirectory, [type])) {
                for (const method of this.getDirectories(debugOutputDirectory, [
                    type,
                    name,
                ])) {
                    for (const statusCode of this.getDirectories(debugOutputDirectory, [
                        type,
                        name,
                        method,
                    ])) {
                        const paths = this.getJSONFiles(debugOutputDirectory, [
                            type,
                            name,
                            method,
                            statusCode,
                        ]);
                        // 1687602187259.json (unixtime[ms].json)
                        // 30日以上前のファイルは削除する
                        const now = Date.now();
                        const deleteFiles = paths.filter((path) => {
                            const file = (0, node_path_1.basename)(path);
                            if (!file) {
                                return false;
                            }
                            const unixtime = Number.parseInt(file.split('.')[0]);
                            return now - unixtime > 1000 * 60 * 60 * 24 * 30;
                        });
                        for (const deleteFile of deleteFiles) {
                            logger.info(`🚮 Delete: ${deleteFile.replace(debugOutputDirectory, '')}`);
                            node_fs_1.default.unlinkSync(deleteFile);
                        }
                        results.push({
                            type,
                            name,
                            method,
                            statusCode,
                            paths: paths.filter((path) => !deleteFiles.includes(path)),
                        });
                    }
                }
            }
        }
        return results;
    },
    /**
     * レスポンスの型定義名を取得する
     *
     * @param rawType リクエストの種別（graphql または rest）
     * @param rawName レスポンスの名前
     * @param rawMethod レスポンスの HTTP メソッド
     * @param rawStatus レスポンスのステータスコード
     * @returns 型定義名
     */
    getName(rawType, rawName, rawMethod, rawStatus) {
        const type = rawType.toLocaleLowerCase() === 'graphql'
            ? 'GraphQL'
            : rawType.toLocaleLowerCase() === 'rest'
                ? 'REST'
                : null;
        if (!type) {
            throw new Error(`Invalid type: ${rawType}`);
        }
        const method = this.toCamelCase(rawMethod);
        const name = this.capitalize(rawName);
        const status = rawStatus === null ? '' : rawStatus.startsWith('2') ? 'Success' : 'Error';
        return `${type}${method}${name}${status}Response`;
    },
    /**
     * キャメルケースに変換する
     *
     * @param string 変換する文字列
     * @returns キャメルケース変換後の文字列
     */
    toCamelCase(string) {
        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
    },
    /**
     * 先頭文字を大文字に変換する
     *
     * @param string 変換する文字列
     * @returns 変換後の文字列
     */
    capitalize(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    },
    /**
     * ファイル名を取得する
     *
     * @param rawType リクエストの種別（graphql または rest）
     * @param rawName レスポンスの名前
     * @param rawMethod レスポンスの HTTP メソッド
     * @param rawStatus レスポンスのステータスコード
     * @returns ファイル名
     */
    getFilename(rawType, rawName, rawMethod, rawStatus) {
        const type = rawType.toLowerCase();
        const method = rawMethod.toLowerCase();
        const name = rawName.replaceAll(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        const status = rawStatus.startsWith('2') ? '-success' : '-error';
        return `${type}/${method}/${name}${status}`;
    },
    /**
     * json-schema-to-typescript のコンパイルオプションを作成・取得する
     *
     * @param tsDocument コンパイル結果の先頭に追加する tsdoc
     * @returns コンパイルオプション
     */
    getCompileOptions(tsDocument) {
        const compileOptions = {
            bannerComment: '/* eslint-disable @typescript-eslint/ban-types */',
            additionalProperties: false,
            enableConstEnums: true,
            strictIndexSignatures: true,
            style: {
                semi: false,
                singleQuote: true,
            },
            unknownAny: true,
        };
        if (tsDocument) {
            compileOptions.bannerComment = `${compileOptions.bannerComment}\n\n/** ${tsDocument} */`;
        }
        return compileOptions;
    },
};
//# sourceMappingURL=utils.js.map