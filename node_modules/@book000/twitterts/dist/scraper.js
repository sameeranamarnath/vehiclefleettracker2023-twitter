"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitterScraper = exports.TwitterScraperPage = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const puppeteer_core_1 = __importDefault(require("puppeteer-core"));
const otplib_1 = require("otplib");
const node_path_1 = require("node:path");
const exceptions_1 = require("./models/exceptions");
const promises_1 = require("node:timers/promises");
/**
 * レスポンスの URL として対象とする URL の定義
 */
const targetUrls = [
    {
        type: 'GRAPHQL',
        hostname: 'api.twitter.com',
        pathnames: ['graphql', '*', '<NAME>'],
    },
    {
        type: 'GRAPHQL',
        hostname: 'twitter.com',
        pathnames: ['i', 'api', 'graphql', '*', '<NAME>'],
    },
    {
        type: 'REST',
        hostname: 'twitter.com',
        pathnames: ['i', 'api', '1.1', '<NAME*>'],
        overrideName: 'V1<NAME>',
    },
    {
        type: 'REST',
        hostname: 'twitter.com',
        pathnames: ['i', 'api', '2', '<NAME*>'],
        overrideName: 'V2<NAME>',
    },
];
function getEndpoint(url) {
    const urlObject = new URL(url);
    if (!urlObject) {
        return null;
    }
    const targets = targetUrls.filter((targetUrl) => targetUrl.hostname === urlObject.hostname);
    if (!targets || targets.length === 0) {
        return null;
    }
    for (const target of targets) {
        const pathnames = target.pathnames;
        const pathname = urlObject.pathname;
        const pathnameParts = pathname.split('/').filter((part) => part !== '');
        let name;
        for (const [index, path] of pathnames.entries()) {
            const part = pathnameParts[index];
            if (path === '*') {
                continue;
            }
            if (path === '<NAME>') {
                if (!part) {
                    break;
                }
                name = part;
                continue;
            }
            if (path === '<NAME*>') {
                if (!part) {
                    break;
                }
                // 以降の値を結合。但し拡張子は除く
                // 例: blocks/create.json -> blocks/create
                name = pathnameParts
                    .slice(index)
                    .join('/')
                    .replace(/\.json$/, '');
                continue;
            }
            if (path !== part) {
                break;
            }
        }
        if (name) {
            return {
                type: target.type,
                name,
                overrideName: target.overrideName,
            };
        }
    }
    return null;
}
/**
 * 取得したレスポンスのチェックを行い、詳細を返します。
 * レスポンスのチェックに失敗した場合は null を返します。
 *
 * @param response チェックし、詳細を返したいレスポンス
 * @returns レスポンスの詳細。チェックに失敗した場合は null
 */
async function getResponseDetails(response) {
    if (response.request().method() === 'OPTIONS') {
        return null;
    }
    let text;
    try {
        text = await response.text();
    }
    catch {
        return null;
    }
    const endpoint = getEndpoint(response.url());
    if (!endpoint) {
        return null;
    }
    const method = response.request().method();
    const type = endpoint.type;
    // name に / がある場合は、その次の文字を大文字にする
    // name に _ がある場合は、その次の文字を大文字にする
    let name = endpoint.name.replaceAll(/[/_](.)/g, (_, p1) => p1.toLocaleUpperCase());
    const overrideName = endpoint.overrideName;
    if (overrideName) {
        name = overrideName.replace('<NAME>', name);
    }
    const key = getResponseKey({
        method,
        type,
        name,
    });
    return {
        key,
        type,
        method,
        name,
        text,
    };
}
/**
 * レスポンスのキーを作成・取得します。
 *
 * @param input レスポンスのキーを作成・取得したいレスポンス
 * @param input.method レスポンスの HTTP メソッド
 * @param input.type レスポンスの種別
 * @param input.name リクエストの名前
 */
function getResponseKey(input) {
    return `${input.type}_${input.method}_${input.name}`.toLocaleUpperCase();
}
/**
 * Twitter スクレイピング ページクラス
 */
class TwitterScraperPage {
    /**
     * @param page Puppeteer のページ
     */
    constructor(page) {
        /**
         * レスポンスの保持オブジェクト
         */
        this.responses = {};
        this.page = page;
        this.setRetentionResponse(page);
    }
    /**
     * 条件に一致するレスポンスをひとつのみ取得します。
     * 指定した timeout 値 (ミリ秒) でタイムアウトします。指定しない場合は 30 秒でタイムアウトします。
     *
     * @param options レスポンス取得オプション
     * @returns レスポンス
     */
    async waitSingleResponse(url, method, type, name, timeout) {
        // レスポンスを待つ
        const promise = new Promise((resolve, reject) => {
            const abortController = new AbortController();
            (0, promises_1.setTimeout)(timeout || 30000, null, {
                signal: abortController.signal,
            })
                .then(() => {
                reject(new exceptions_1.TwitterTimeoutError('Response timeout.'));
            })
                .catch((error) => {
                // ignore abort error
                if (abortController.signal.aborted) {
                    return;
                }
                reject(error);
            });
            const key = getResponseKey({
                method,
                type,
                name,
            });
            setInterval(() => {
                const responses = this.responses[key];
                if (responses && responses.length > 0) {
                    const response = responses.shift();
                    if (response) {
                        abortController.abort();
                        if (response === 'Rate limit exceeded') {
                            reject(new exceptions_1.TwitterRateLimitError());
                            return;
                        }
                        if (!response.trimStart().startsWith('[') &&
                            !response.trimStart().startsWith('{')) {
                            reject(new exceptions_1.TwitterOperationError(`Invalid response: ${response.slice(0, 100)}`));
                            return;
                        }
                        resolve(JSON.parse(response));
                    }
                }
            }, 500);
        });
        // ページ遷移
        if (url) {
            await this.page.goto(url);
        }
        return await promise;
    }
    /**
     * 条件に一致するレスポンスをひとつ取得します。繰り返し呼び出すことで複数のレスポンスを取得できます。
     * waitSingleResponse と異なり、レスポンス待ちを行わず、ページ遷移もしません（goto メソッドによるページ遷移が必要です）。
     *
     * @param options レスポンス取得オプション
     * @returns レスポンス。一致するレスポンスがない場合は null
     */
    shiftResponse(method, type, name) {
        const key = getResponseKey({
            method,
            type,
            name,
        });
        const responses = this.responses[key];
        if (!responses || responses.length === 0) {
            return null;
        }
        const response = responses.shift();
        if (!response) {
            return null;
        }
        if (response === 'Rate limit exceeded') {
            throw new exceptions_1.TwitterRateLimitError();
        }
        if (!response.trimStart().startsWith('[') &&
            !response.trimStart().startsWith('{')) {
            throw new exceptions_1.TwitterOperationError(`Invalid response: ${response.slice(0, 100)}`);
        }
        return JSON.parse(response);
    }
    /**
     * 指定した URL に遷移します。
     *
     * @param url 遷移先 URL
     */
    async goto(url) {
        await this.page.goto(url, {
            waitUntil: ['load', 'networkidle2'],
        });
    }
    /**
     * 要素を探し、描画範囲内に表示されるようにスクロールしたあと、クリックします。
     * 要素が検索処理は、指定した timeout 値 (ミリ秒) でタイムアウトします。指定しない場合は 30 秒でタイムアウトします。
     *
     * @param selector 要素のセレクタ
     */
    async waitAndClick(selector, isEvaluate = false, timeout) {
        const element = await this.page
            .waitForSelector(selector, {
            timeout: timeout || 30000,
        })
            .catch(() => null);
        if (!element) {
            throw new exceptions_1.TwitterOperationError(`Element not found: ${selector}`);
        }
        await this.page.evaluate((element) => element?.scrollIntoView(), element);
        await (isEvaluate
            ? this.page.evaluate((selector) => {
                const element = document.querySelector(selector);
                if (element) {
                    // @ts-ignore
                    element.click();
                }
            }, selector)
            : element.click());
    }
    /**
     * リダイレクトを待ち、リダイレクト先の URL を返します。
     *
     * @param sourceUrl リダイレクト前の URL
     * @returns リダイレクト先の URL
     */
    async getRedirectTo(sourceUrl, timeout = 30000) {
        return new Promise((resolve, reject) => {
            const abortController = new AbortController();
            (0, promises_1.setTimeout)(timeout || 30000, null, {
                signal: abortController.signal,
            })
                .then(() => {
                clearInterval(intervalId);
                reject(new exceptions_1.TwitterTimeoutError('Redirect timeout.'));
            })
                .catch((error) => {
                // ignore abort error
                if (abortController.signal.aborted) {
                    return;
                }
                throw error;
            });
            const intervalId = setInterval(async () => {
                const url = await this.page.evaluate(() => document.location.href);
                if (url === sourceUrl) {
                    return;
                }
                clearInterval(intervalId);
                abortController.abort();
                resolve(url);
            }, 500);
        });
    }
    /**
     * ページの最下部までスクロールします。
     */
    async scrollToBottom() {
        await this.page.evaluate(() => {
            const scrollHeight = document.documentElement.scrollHeight;
            window.scrollTo({
                top: scrollHeight,
                behavior: 'smooth',
            });
        });
        await (0, promises_1.setTimeout)(1000);
    }
    /**
     * ページを閉じます。
     */
    async close() {
        await this.page.close();
    }
    /**
     * レスポンスを保持するようにハンドラを設定します。
     *
     * @param page Puppeteer ページインスタンス
     */
    setRetentionResponse(page) {
        page.on('response', async (response) => {
            const details = await getResponseDetails(response);
            if (!details) {
                return;
            }
            const { key, text } = details;
            this.responses[key] = this.responses[key] || [];
            this.responses[key].push(text);
        });
    }
}
exports.TwitterScraperPage = TwitterScraperPage;
/**
 * Twitter スクレイピングクラス
 */
class TwitterScraper {
    /**
     * @param options Twitter スクレイピングオプション
     */
    constructor(options) {
        this.options = options;
    }
    /**
     * Twitter にログインします。
     */
    async login() {
        // ブラウザ作成
        this.browser = await this.createBrowser();
        // ログイン処理
        const loginPage = await this.newPage();
        await loginPage.goto('https://twitter.com', {
            waitUntil: ['load', 'networkidle2'],
        });
        await (0, promises_1.setTimeout)(3000);
        const href = await loginPage.evaluate(() => {
            return document.location.href;
        });
        if (href !== 'https://twitter.com/home') {
            await loginPage.goto('https://twitter.com/i/flow/login', {
                waitUntil: ['load', 'networkidle2'],
            });
            const username = this.options.username;
            await loginPage
                .waitForSelector('input[autocomplete="username"]')
                .then((element) => element?.type(username, { delay: 100 }))
                .catch((error) => new exceptions_1.TwitterOperationError('Username input not found.', error));
            // next button
            await loginPage
                .waitForSelector('div[role="button"]:not([data-testid])')
                .then((element) => element?.click())
                .catch((error) => new exceptions_1.TwitterOperationError('Next button not found.', error));
            const password = this.options.password;
            // password
            await loginPage
                .waitForSelector('input[autocomplete="current-password"]')
                .then((element) => element?.type(password, { delay: 100 }))
                .catch((error) => new exceptions_1.TwitterOperationError('Password input not found.', error));
            // login button
            await loginPage
                .waitForSelector('div[role="button"][data-testid="LoginForm_Login_Button"]')
                .then((element) => element?.click())
                .catch((error) => new exceptions_1.TwitterOperationError('Login button not found.', error));
            // need auth code ?
            const authCodeInput = await this.getElement(loginPage, 'input[data-testid="ocfEnterTextTextInput"]', 3000);
            if (authCodeInput) {
                const authCodeSecret = this.options.otpSecret;
                if (!authCodeSecret) {
                    throw new exceptions_1.TwitterOperationError('OTP secret not found.');
                }
                const authCode = this.getOneTimePassword(authCodeSecret);
                await authCodeInput.type(authCode, { delay: 100 });
                await loginPage
                    .waitForSelector('div[role="button"][data-testid="ocfEnterTextNextButton"]')
                    .then((element) => element?.click())
                    .catch((error) => new exceptions_1.TwitterOperationError('OTP next button not found.', error));
                await new Promise((resolve, reject) => {
                    const abortController = new AbortController();
                    (0, promises_1.setTimeout)(10000, null, {
                        signal: abortController.signal,
                    })
                        .then(() => {
                        reject(new exceptions_1.TwitterTimeoutError('Login timeout.'));
                    })
                        .catch((error) => {
                        // ignore abort error
                        if (abortController.signal.aborted) {
                            return;
                        }
                        throw error;
                    });
                    const interval = setInterval(() => {
                        if (loginPage.url() === 'https://twitter.com/home') {
                            clearInterval(interval);
                            abortController.abort();
                            resolve();
                        }
                    }, 500);
                });
            }
            await loginPage.close();
        }
    }
    /**
     * TwitterScraperPage インスタンスを作成します。
     *
     * @returns TwitterScraperPage インスタンス
     */
    async getScraperPage() {
        const page = await this.newPage();
        return new TwitterScraperPage(page);
    }
    /**
     * ブラウザを閉じます。
     */
    async close() {
        if (!this.browser) {
            return;
        }
        await this.browser.close();
    }
    getBrowser() {
        return this.browser;
    }
    /**
     * Puppeteer ブラウザインスタンスを作成します。
     *
     * @returns Puppeteer ブラウザインスタンス
     */
    async createBrowser() {
        const width = this.options.puppeteerOptions?.defaultViewport?.width || 600;
        const height = this.options.puppeteerOptions?.defaultViewport?.height || 1000;
        const puppeteerArguments = [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--lang=ja',
            `--window-size=${width},${height}`,
            '--disable-session-crashed-bubble',
        ];
        if (this.options.puppeteerOptions?.enableDevtools) {
            puppeteerArguments.push('--auto-open-devtools-for-tabs');
        }
        if (this.options.puppeteerOptions?.proxy &&
            this.options.puppeteerOptions?.proxy.server) {
            puppeteerArguments.push('--proxy-server=' + this.options.puppeteerOptions.proxy.server);
        }
        const userDataDirectory = this.options.puppeteerOptions?.userDataDirectory || '/data/userdata';
        const browser = await puppeteer_core_1.default.launch({
            headless: false,
            executablePath: this.options.puppeteerOptions?.executablePath,
            channel: 'chrome',
            args: puppeteerArguments,
            defaultViewport: {
                width,
                height,
            },
            userDataDir: userDataDirectory,
        });
        process.on('SIGINT', async () => {
            await browser.close();
            process.exit(0);
        });
        return browser;
    }
    /**
     * 新しいページを作成します。
     */
    async newPage() {
        if (!this.browser) {
            throw new exceptions_1.TwitterOperationError('Failed to create page. Browser is not initialized.');
        }
        const page = await this.browser.newPage();
        page.setDefaultNavigationTimeout(120 * 1000);
        await page.evaluateOnNewDocument(() => {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            Object.defineProperty(navigator, 'webdriver', () => { });
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            // eslint-disable-next-line no-proto
            delete navigator.__proto__.webdriver;
        });
        if (this.options.puppeteerOptions?.proxy &&
            this.options.puppeteerOptions?.proxy.username &&
            this.options.puppeteerOptions?.proxy.password) {
            await page.authenticate({
                username: this.options.puppeteerOptions.proxy.username,
                password: this.options.puppeteerOptions.proxy.password,
            });
        }
        this.setAutoSaveResponse(page);
        return page;
    }
    /**
     * レスポンスを自動保存するハンドラを設定します。
     *
     * @param page Puppeteer ページインスタンス
     */
    setAutoSaveResponse(page) {
        if (!this.options.debugOptions?.outputResponse?.enable) {
            return;
        }
        page.on('response', async (response) => {
            const details = await getResponseDetails(response);
            if (!details) {
                return;
            }
            const url = response.url();
            const { type, name, method, text } = details;
            const onResponse = this.options.debugOptions?.outputResponse?.onResponse;
            if (onResponse) {
                onResponse(details);
            }
            const pathNotIncludedExtension = (0, node_path_1.join)(this.options.debugOptions?.outputResponse?.outputDirectory ||
                '/data/debug', type.toLowerCase(), name, method, response.status().toString(), `${Date.now()}.`);
            node_fs_1.default.mkdirSync((0, node_path_1.dirname)(pathNotIncludedExtension), { recursive: true });
            try {
                const data = JSON.parse(text);
                const path = `${pathNotIncludedExtension}json`;
                const body = `// ${method} ${url}\n\n${JSON.stringify(data, null, 2)}`;
                node_fs_1.default.writeFileSync(path, body);
            }
            catch {
                const path = `${pathNotIncludedExtension}txt`;
                node_fs_1.default.writeFileSync(path, text);
            }
        });
    }
    /**
     * 指定したセレクタの要素を取得します。
     *
     * @param page Puppeteer ページインスタンス
     * @param selector セレクタ
     * @param timeout タイムアウトミリ秒
     * @returns 要素。見つからなかった場合は null
     */
    async getElement(page, selector, timeout = 3000) {
        try {
            return await page.waitForSelector(selector, { timeout });
        }
        catch {
            return null;
        }
    }
    /**
     * シークレットをもとに OTP を生成します。
     *
     * @param secret シークレット
     * @returns OTP コード
     */
    getOneTimePassword(secret) {
        return otplib_1.authenticator.generate(secret);
    }
}
exports.TwitterScraper = TwitterScraper;
//# sourceMappingURL=scraper.js.map