"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchTimelineParser = void 0;
const base_1 = require("./base");
/**
 * {@link Twitter.searchTweets} のレスポンスパーサー
 */
class SearchTimelineParser extends base_1.BaseParser {
    /**
     * @param response {@link Twitter['searchTweets']} のレスポンス
     */
    constructor(response, isIncludingPromotedTweets) {
        super(response);
        this.rawTweets = [];
        const entries = this.response.data.search_by_raw_query.search_timeline.timeline.instructions
            .filter((instruction) => instruction.type === 'TimelineAddEntries' && instruction.entries)
            .flatMap((instruction) => instruction.entries?.filter((entry) => entry.entryId.startsWith('tweet-') ||
            (isIncludingPromotedTweets
                ? entry.entryId.startsWith('promoted-tweet') ||
                    entry.entryId.startsWith('promotedTweet')
                : false)));
        const rawTweets = entries
            .map((entry) => {
            return {
                __entryId: entry.entryId,
                ...entry.content.itemContent.tweet_results.result,
            };
        })
            .filter((tweet) => !!tweet);
        this.rawTweets = rawTweets;
    }
    /**
     * 検索結果の非正規化ツイート群を取得する
     *
     * @returns 非正規化ツイートの配列
     */
    getRawTweets() {
        return this.rawTweets;
    }
}
exports.SearchTimelineParser = SearchTimelineParser;
//# sourceMappingURL=search-timeline.js.map